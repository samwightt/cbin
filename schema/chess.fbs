//! Chess schema
namespace Chess;

/// Represents a movable piece in a chess game.
enum Piece: ubyte {
  Pawn = 0,
  Knight = 1,
  Bishop = 2,
  Rook = 3,
  Queen = 4,
  King = 5
}

/// One of the squares on the board.
enum Square: ubyte {
  A1 = 0, B1 = 1, C1 = 2, D1 = 3, E1 = 4, F1 = 5, G1 = 6, H1 = 7,
  A2 = 8, B2 = 9, C2 = 10, D2 = 11, E2 = 12, F2 = 13, G2 = 14, H2 = 15,
  A3 = 16, B3 = 17, C3 = 18, D3 = 19, E3 = 20, F3 = 21, G3 = 22, H3 = 23,
  A4 = 24, B4 = 25, C4 = 26, D4 = 27, E4 = 28, F4 = 29, G4 = 30, H4 = 31,
  A5 = 32, B5 = 33, C5 = 34, D5 = 35, E5 = 36, F5 = 37, G5 = 38, H5 = 39,
  A6 = 40, B6 = 41, C6 = 42, D6 = 43, E6 = 44, F6 = 45, G6 = 46, H6 = 47,
  A7 = 48, B7 = 49, C7 = 50, D7 = 51, E7 = 52, F7 = 53, G7 = 54, H7 = 55,
  A8 = 56, B8 = 57, C8 = 58, D8 = 59, E8 = 60, F8 = 61, G8 = 62, H8 = 63
}

/// Valid promotable pieces.
enum PromotedPiece: ubyte {
  Knight = 1,
  Bishop = 2,
  Rook = 3,
  Queen = 4,
}

/// Which way the pieces are castled (if they are at all).
enum CastleKind: ubyte {
  Kingside,
  Queenside
}

enum Rank: ubyte {
  First = 1,
  Second = 2,
  Third = 3,
  Fourth = 4,
  Fifth = 5,
  Sixth = 6,
  Seventh = 7,
  Eighth = 8,
}

enum File: ubyte {
  A = 1,
  B = 2,
  C = 3,
  D = 4,
  E = 5,
  F = 6,
  G = 7,
  H = 8,
}

/// A move in a normal game.
table Move {
  /// The piece that is moved.
  moved_piece: Piece;
  /// Used for disambiguation of moves with the same piece type that can move to the same destination square.
  /// Follows same semantics as PGN notation:
  /// 1. If pieces can be disambiguated by file, the file is used.
  /// 2. If pieces can be disambiguated by rank, the rank is used.
  /// 3. If pieces can be disambiguated by file and rank, the file and rank are used.
  from_file: File = null;
  /// Used for disambiguation of moves with the same piece type that can move to the same destination square.
  /// 1. If pieces can be disambiguated by file, the file is used.
  /// 2. If pieces can be disambiguated by rank, the rank is used.
  /// 3. If pieces can be disambiguated by file and rank, the file and rank are used.
  from_rank: Rank = null;
  to: Square;
  promoted_piece: Piece = null;
  /// CASTLING SEMANTICS: The moved_piece MUST be Piece::King, the `to` square can be filled
  /// in with any square. Implementations should ignore `from` and `to` squares when `castle` is set.
  castle: CastleKind = null;
  is_capture: bool = false;
}

/// Result of the game. Either white wins, black wins, there is a draw, or the result is unknown.
/// Unknown is equivalent to the PGN ? syntax.
enum GameResult: ubyte {
  WhiteWin = 0,
  BlackWin = 1,
  Draw = 2,
  // Equivalent to PGN ?
  Unknown = 3
}

/// Information about a game. Equivalent to the PGN tags section.
table GameInfo {
  /// Equivalent to the PGN [Event] tag. Platforms like Chess.com simply use a string like 'Live Chess' here. Others
  /// like Lichess have more specific data.
  event: string;
  /// Equivalent to the PGN [Site] tag.
  site: string;
  /// Publicly accessible URL of the game. Some resources like the Lichess DB include this as a tag in their PGN [Site] tag.
  url: string;
  /// Name or username of the white player.
  white_player: string;
  /// Name or username of the black player.
  black_player: string;
  /// Elo of the white player.
  white_elo: uint;
  /// Elo of the black player.
  black_elo: uint;
}

/// A normal chess game. Has moves and a result.
table Game {
  result: GameResult;
  /// FEN string of the start position (if applicable).
  start_position: string;
  moves: [Move] (required);
}

/// An archive of traditional chess games.
table Archive {
  games: [Game] (required);
}

/// An archive is a list of games. There can be different types of archives, for different variants of chess.
/// As such, we use a union to reserve future space for other variant support.
/// Implementations are free to ignore archives of variants they do not support.
union ArchiveType { Archive }

/// A block in the file. Unions cannot be the root of a flatbuffer,
/// so we must have a table here. May contain information about the archive (eg. source of the games,
/// serializing software, etc.) in the future.
table Block {
  archive: ArchiveType (required);
}

root_type Block;
